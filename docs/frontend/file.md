# file







大文件切片上传，断点续传

先调后端接口，给文件名，创建时间，更新事件，文件大小，判断这个文件是否已上传？

如果没有，后端会返回一个 upload task，包含 task id，task name（file name），前端直接开始切片上传即可。

后端判断这个文件名，是否已上传，如果文件的更新时间不一致，后端要抛出错误，如果出现同名的 upload task，让用户自己判断，是否继续，还是直接覆盖，或者说，告诉用户。

如果已上传，后端还会返回已上传的 md5 数组，前端开始循环创建切片的时候，把已经上传上去的 md5给 filter，如果 md5 值不一致，说明文件改动了，就不能再上传了。

先通过 statSync 读取文件的大小，10G
根据规则切片
创建只读流，每次读取切片大小，调用上传接口，把切片总长度和当前索引，md5，文件名，创建时间，更新时间，buffer 内容，全部通过 formData 上传给服务端。
用户关闭，那就停止上传了，后端拿到的只是前面10个切片。

用户点继续上传，前端调用后端接口，让后端判断，现在该传哪个索引了，用户重新从新的索引开始切片，重复上面的过程

这种做法不对，正确的做法是，用户点击继续上传，后端把已经上传的 hash 数组全部返回给前端，前端去读取本地路径的文件，重新切片，以前的切片拿到 hash 值，跟已经上传的 hash 值对比，如果一致，那就 continue，如果不一致，那就说明文件被改过了，就不能再继续上传了。就告知用户，文件已损坏，或者文件已修改。

其中某一个切片，上传失败，是需要重新上传2次

最后一个切片上传成功后，客户端和服务端，都需要拿着完整的文件哈希值去对比么？
因为只有前端知道什么时候才是最后一个切片，而后端是不知道的，

如何占满用户的上行带宽用来上传。







uppy 是一个js的文件上传插件，支持上传进度，在线预览等多个功能，并且能从本地磁盘、Dropbox、Instagram、远程 URL、Google 云端硬盘、摄像机和其他位置导入文件。


dropzone 文件拖拽上传